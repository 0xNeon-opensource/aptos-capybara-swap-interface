/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

import 'workbox-precaching' // defines __WB_MANIFEST

import { clientsClaim, RouteHandlerCallbackOptions, RouteMatchCallbackOptions } from 'workbox-core'
import * as navigationPreload from 'workbox-navigation-preload'
import { registerRoute } from 'workbox-routing'

// Set to true to disable checks for domain and etags (which are not generated by simple servers).
const isLocal = false

navigationPreload.enable()
clientsClaim()

/*
 * Assets are cached natively by the browser, so the manifest is unused by this ServiceWorker.
 * However, workbox will not work unless __WB_MANIFEST is present in this file.
 * TODO(leggechr): Add back in manifest precaching.
 */
declare const self: ServiceWorkerGlobalScope
void self.__WB_MANIFEST

registerRoute(matchDocument, handleDocument)

const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$')

function matchDocument({ request, url }: RouteMatchCallbackOptions) {
  // If this isn't app.uniswap.org (or a local build), skip.
  // IPFS gateways may not have domain separation, so they cannot use document caching.
  if (url.hostname !== 'app.uniswap.org' && !isLocal) {
    return false
  }

  // If this isn't a navigation, skip.
  if (request.mode !== 'navigate') {
    return false
  }

  // If this looks like a resource (ie has a file extension), skip.
  if (url.pathname.match(fileExtensionRegexp)) {
    return false
  }

  return true
}

const DOCUMENT_HTML = process.env.PUBLIC_URL + '/index.html'
let cachedDocument: Response | undefined

/*
 * The returned document should always be fresh, so the handler uses a custom strategy:
 *
 * - Always fetch the latest document (using navigationPreload, if supported)
 * - When available, compare the etag headers of the latest and cached documents:
 *   - If matching, return the cached document (this avoids waiting for the latest document response).
 *   - If not matching, return the latest document.
 * - When fetched, update the cache with the latest document.
 *
 * This ensures that the user will always see the latest document. It requires a network fetch to
 * check the cache document's freshness, but does not require a full fetch, so it still saves time.
 */
async function handleDocument({ event }: RouteHandlerCallbackOptions) {
  const { preloadResponse } = event as unknown as { preloadResponse: Promise<Response | undefined> }
  const controller = new AbortController()
  const response = (await preloadResponse) || (await fetch(DOCUMENT_HTML, { signal: controller.signal }))

  // The etag header can be queried before the entire response body has streamed. In testing, the
  // etag header was available in 1/5 the time of the response body, so this is still an effective
  // caching strategy.
  const etag = response.headers.get('etag')
  const cachedEtag = cachedDocument?.headers.get('etag')
  if (cachedDocument && (isLocal || etag) && etag === cachedEtag) {
    // If the cache is still fresh, cancel the pending response. The preloadResponse is cancelled
    // automatically by returning before it is settled; cancelling the preloadResponse will log
    // an error to the console, but it can be ignored - it *should* be cancelled.
    controller.abort()
  } else {
    cachedDocument = response
  }
  // TODO(leggechr): Send beacons with metrics to track usage/load times. This should probably be
  // done on the client, not the serviceworker. Cached responses can have a header added to indicate
  // that they were served from cache.

  // Responses are one-use only; use a a clone for re-use of the cached Response.
  return cachedDocument.clone()
}
