/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

import 'workbox-precaching' // defines __WB_MANIFEST

import { clientsClaim, RouteHandlerCallbackOptions, RouteMatchCallbackOptions } from 'workbox-core'
import * as navigationPreload from 'workbox-navigation-preload'
import { registerRoute } from 'workbox-routing'

// Set to true to disable checks for domain and etags (which are not generated by simple servers).
const isLocal = false

/*
 * The ServiceWorker will only serve the document, and only if it is fresh, using a custom strategy:
 *
 * - Always fetch the latest document (using navigationPreload, if supported)
 * - When available, compare the etag headers of the latest and cached documents:
 *   - If matching, return the cached document (to avoid waiting for the entire document to fetch).
 *   - If not matching, return the fetched document.
 * - When fetched, update the cache with the latest document.
 *
 * This ensures that the user will always see the latest document, and only requires the user to
 * download the document etag header for each navigation.
 */

navigationPreload.enable()
clientsClaim()

/*
 * Assets are cached natively by the browser, so the manifest is unused by this ServiceWorker.
 * However, workbox will not work unless __WB_MANIFEST is present in this file.
 */
declare const self: ServiceWorkerGlobalScope
void self.__WB_MANIFEST

// Set up App Shell-style matching, so that navigation requests are fulfilled with a fresh cached
// local index.html shell.
// See https://developers.google.com/web/fundamentals/architecture/app-shell
registerRoute(matchAppShell, handleAppShell)

const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$')

function matchAppShell({ request, url }: RouteMatchCallbackOptions) {
  // If this isn't app.uniswap.org, skip. IPFS gateways may not have domain
  // separation, so they cannot use App Shell-style routing.
  if (url.hostname !== 'app.uniswap.org' && !isLocal) {
    return false
  }

  // If this isn't a navigation, skip.
  if (request.mode !== 'navigate') {
    return false
  }

  // If this looks like a URL for a resource, skip.
  if (url.pathname.match(fileExtensionRegexp)) {
    return false
  }

  return true
}

const APP_SHELL_HTML = process.env.PUBLIC_URL + '/index.html'
let cachedAppShell: Response | undefined

async function handleAppShell({ request, event }: RouteHandlerCallbackOptions) {
  // NB: If the cached response is used, the preloadResponse may be cancelled before it is settled.
  // This will log an error to the console, but it can be ignored - it *should* be cancelled.
  const { preloadResponse } = event as unknown as { preloadResponse: Promise<Response | undefined> }
  const controller = new AbortController()
  const response = (await preloadResponse) || (await fetch(APP_SHELL_HTML, { signal: controller.signal }))

  // Only serve from the cache if the cache is still fresh (checked using etag comparison). The etag
  // header can be queried before the response has streamed, so this still reduces network time.
  // (In manual testing, etag lookup took only 2-20% of the total response download time.)
  const etag = response.headers.get('etag')
  const cachedEtag = cachedAppShell?.headers.get('etag')
  if (cachedAppShell && (isLocal || etag) && etag === cachedEtag) {
    // If the cache is still fresh, cancel any pending response. The preloadResponse is cancelled
    // automatically by returning before it is settled.
    controller.abort()
  } else {
    cachedAppShell = response
  }
  // TODO(leggechr): Send beacons with metrics to track usage/load times. This should probably be done on the client, not the serviceworker.
  // Cached responses can have a header added to indicate that they were served from cache.

  const clone = cachedAppShell.clone()
  return clone
}
